# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Estimate the nonhomgogenous poisson process intensity function from grouped data
#' 
#' @template bda 
#'
#' @param r vector of distances associatd with different BEFs
#' @param n_j matrix of integers denoting the start and length of each observations associated BEF distances
#' @param d a 1D grid of positive real values over which the differing intensities are evaluated
#' @param L component truncation number
#' @param K intensity cluster truncation number
#' @param J number of rows in r matrix; number of groups
#' @param mu_0 normal base measure prior mean
#' @param kappa_0 normal base measure prior variance scale 
#' @param nu_0 inverse chi sqaure base measure prior degrees of freedom
#' @param sigma_0 inverse chi square base measure prior scale  
#' @param a_alpha hyperparameter for alpha gamma prior
#' @param b_alpha scale hyperparameter for alpha gamma prior
#' @param a_rho hyperparameter for rho gamma prior
#' @param b_rho scale hyperparameter for rho gamma prior
#' @param iter_max total number of iterations for which to run sampler
#' @param warm_up number of iterations for which to burn-in or "warm-up" sampler
#' @param thin number of iterations to thin by
#' @param seed integer with which to initialize random number generator
#' @param chain integer chain label
#' @param num_posterior_samples the total number of posterior samples after burn in 
#' @seealso the conjugate normal parameterization in the reference below
#'
nd_nhpp_fit <- function(r, n_j, d, L, K, J, mu_0, kappa_0, nu_0, sigma_0, a_alpha, b_alpha, a_rho, b_rho, iter_max, warm_up, thin, seed, chain, num_posterior_samples) {
    .Call(`_bendr_nd_nhpp_fit`, r, n_j, d, L, K, J, mu_0, kappa_0, nu_0, sigma_0, a_alpha, b_alpha, a_rho, b_rho, iter_max, warm_up, thin, seed, chain, num_posterior_samples)
}

#' Estimate the nonhomgogenous poisson process intensity function from grouped data with fixed concentration parameters
#'
#' @template bda
#'
#'
#' @param r vector of distances associatd with different BEFs
#' @param n_j matrix of integers denoting the start and length of each observations associated BEF distances
#' @param d a 1D grid of positive real values over which the differing intensities are evaluated
#' @param L component truncation number
#' @param K intensity cluster truncation number
#' @param J number of rows in r matrix; number of groups
#' @param mu_0 normal base measure prior mean
#' @param kappa_0 normal base measure prior variance scale 
#' @param nu_0 inverse chi sqaure base measure prior degrees of freedom
#' @param sigma_0 inverse chi square base measure prior scale  
#' @param alpha upper level concentration parameter (fixed)
#' @param rho lower level concentration parameter (fixed)
#' @param iter_max total number of iterations for which to run sampler
#' @param warm_up number of iterations for which to burn-in or "warm-up" sampler
#' @param thin number of iterations to thin by
#' @param seed integer with which to initialize random number generator
#' @param chain integer chain label
#' @param num_posterior_samples the total number of posterior samples after burn in 
#' @seealso the normal-inverse Chi-square conjugate parameterization in the reference
#'
nd_nhpp_fixed_fit <- function(r, n_j, d, L, K, J, mu_0, kappa_0, nu_0, sigma_0, alpha, rho, iter_max, warm_up, thin, seed, chain, num_posterior_samples) {
    .Call(`_bendr_nd_nhpp_fixed_fit`, r, n_j, d, L, K, J, mu_0, kappa_0, nu_0, sigma_0, alpha, rho, iter_max, warm_up, thin, seed, chain, num_posterior_samples)
}

#' Estimate the nonhomgogenous poisson process intensity function from grouped data  
#' 
#' @param r vector of distances associatd with different BEFs 
#' @param n_j matrix of integers denoting the start and length of each school's associated BEF distances
#' @param d a 1D grid of positive real values over which the differing intensities are evaluated 
#' @param mu_sd scale for mu proposal dist'n
#' @param tau_sd scale for tau proposal dist'n
#' @param L component truncation number
#' @param K intensity cluster truncation number
#' @param J number of rows in r matrix; number of groups
#' @param a_0 hyperparameter for mu base measure
#' @param b_0 hyperparameter for mu base measure
#' @param a_alpha hyperparameter for alpha gamma prior
#' @param b_alpha hyperparameter for alpha gamma prior
#' @param a_rho hyperparameter for rho gamma prior
#' @param b_rho hyperparameter for rho gamma prior
#' @param iter_max total number of iterations for which to run sampler
#' @param warm_up number of iterations for which to burn-in or "warm-up" sampler
#' @param thin number of iterations to thin by
#' @param seed integer with which to initialize random number generator
#' @param chain integer chain label
#'
beta_nd_nhpp_fit <- function(r, n_j, d, mu_sd, tau_sd, L, K, J, a_0, b_0, a_alpha, b_alpha, a_rho, b_rho, iter_max, warm_up, thin, seed, chain) {
    .Call(`_bendr_beta_nd_nhpp_fit`, r, n_j, d, mu_sd, tau_sd, L, K, J, a_0, b_0, a_alpha, b_alpha, a_rho, b_rho, iter_max, warm_up, thin, seed, chain)
}

#' Estimate the nonhomgogenous poisson process intensity function from grouped data using multiple taus 
#' 
#' @param r vector of distances associatd with different BEFs 
#' @param n_j matrix of integers denoting the start and length of each school's associated BEF distances
#' @param d a 1D grid of positive real values over which the differing intensities are evaluated 
#' @param mu_sd scale for mu proposal dist'n
#' @param tau_sd  not used
#' @param L component truncation number
#' @param K intensity cluster truncation number
#' @param J number of rows in r matrix; number of groups
#' @param a_0 hyperparameter for mu base measure
#' @param b_0 hyperparameter for mu base measure
#' @param a_alpha hyperparameter for alpha gamma prior
#' @param b_alpha hyperparameter for alpha gamma prior
#' @param a_rho hyperparameter for rho gamma prior
#' @param b_rho hyperparameter for rho gamma prior
#' @param iter_max total number of iterations for which to run sampler
#' @param warm_up number of iterations for which to burn-in or "warm-up" sampler
#' @param thin number of iterations to thin by
#' @param seed integer with which to initialize random number generator
#' @param chain integer chain label
#'
beta_nd_nhpp_fit_multiple_taus <- function(r, n_j, d, mu_sd, tau_sd, L, K, J, a_0, b_0, a_alpha, b_alpha, a_rho, b_rho, iter_max, warm_up, thin, seed, chain) {
    .Call(`_bendr_beta_nd_nhpp_fit_multiple_taus`, r, n_j, d, mu_sd, tau_sd, L, K, J, a_0, b_0, a_alpha, b_alpha, a_rho, b_rho, iter_max, warm_up, thin, seed, chain)
}

#' Returns draw of beta regression coefficients from posterior distribution via No U-Turn Sampler
#'
#' @template nuts 
#' @param warm_up number of iterations for which to tune step-size 
#' @param iter_max total number of iterations for which to run the sampler
#' @param input_X design matrix
#' @param input_n_j outcome of counts
#' @param adapt_delta (0,1) scalar that denotes the average acceptance probability 
#' @param seed random number generator seed
#' @seealso the reference linked
#'
nhpp_gamma <- function(warm_up, iter_max, input_X, input_n_j, adapt_delta, seed) {
    .Call(`_bendr_nhpp_gamma`, warm_up, iter_max, input_X, input_n_j, adapt_delta, seed)
}

#' Computes Green and Lau loss function with unknown classification
#'
#' @param cluster_assignment iter_total x J cluster assignment matrix
#' @param pmat J x J pairwise probability of co-clustering matrix
#' @param tau penalty parameter 
green_loss_unknown <- function(cluster_assignment, pmat, tau) {
    .Call(`_bendr_green_loss_unknown`, cluster_assignment, pmat, tau)
}

#' Computes Green and Lau Loss function with known classification
#'
#' @param cluster_assignment iter_total x J cluster assignment matrix
#' @param pmat J x J pairwise probability of co-clustering matrix
#' @param true_cluster_assignment J x J true Adjacency Matrix
#' @param a mis-classification penalty parameter
#' @param b classification penalty parameter
green_loss_known <- function(cluster_assignment, pmat, true_cluster_assignment, a, b) {
    .Call(`_bendr_green_loss_known`, cluster_assignment, pmat, true_cluster_assignment, a, b)
}

#' Computes Square loss with unknown classification
#'
#' @param cluster_assignment iter_total x J cluster assignment matrix
#' @param pmat J x J pairwise probability of co-clustering matrix
square_error <- function(cluster_assignment, pmat) {
    .Call(`_bendr_square_error`, cluster_assignment, pmat)
}

#' Estimate the Multivariate nonhomgogenous poisson process intensity function from grouped data via Nested Dirichlet Process
#' 
#' @template bda 
#'
#' @param r matrix of distances associatd with different BEFs
#' @param n_j matrix of integers denoting the start and length of each observations associated BEF distances
#' @param d a 1D grid of positive real values over which the differing intensities are evaluated
#' @param L component truncation number
#' @param K intensity cluster truncation number
#' @param J number of rows in r matrix; number of groups
#' @param mu_0 normal base measure prior mean
#' @param kappa_0 normal base measure prior variance scale 
#' @param nu_0 inverse chi sqaure base measure prior degrees of freedom
#' @param sigma_0 inverse chi square base measure prior scale  
#' @param a_alpha hyperparameter for alpha gamma prior
#' @param b_alpha scale hyperparameter for alpha gamma prior
#' @param a_rho hyperparameter for rho gamma prior
#' @param b_rho scale hyperparameter for rho gamma prior
#' @param iter_max total number of iterations for which to run sampler
#' @param warm_up number of iterations for which to burn-in or "warm-up" sampler
#' @param thin number of iterations to thin by
#' @param seed integer with which to initialize random number generator
#' @param chain integer chain label
#' @param num_posterior_samples the total number of posterior samples after burn in 
#' @seealso the conjugate normal parameterization in the reference below
#'
nd_nhpp_multivariate_fit <- function(r, n_j, d, L, K, J, mu_0, kappa_0, nu_0, sigma_0, a_alpha, b_alpha, a_rho, b_rho, iter_max, warm_up, thin, seed, chain, num_posterior_samples) {
    .Call(`_bendr_nd_nhpp_multivariate_fit`, r, n_j, d, L, K, J, mu_0, kappa_0, nu_0, sigma_0, a_alpha, b_alpha, a_rho, b_rho, iter_max, warm_up, thin, seed, chain, num_posterior_samples)
}

